#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Nov 11 15:55:19 2025

@author: abbybirchall
"""

import json
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import brentq

# 1) Physical constants and global parameters

A_default = 1.0                   # basin area (m^2) — can be changed or root-searched
water_depth = 0.02                # m (20 mm)
glass_thickness = 0.004           # m (4 mm)
rho_water = 1000.0                # kg/m3
rho_glass = 2500.0                # kg/m3
c_w = 4186.0                      # J/(kg K)
c_g = 750.0                       # J/(kg K)
epsilon_g = 0.9                   # glass emissivity (effective)
sigma = 5.670374419e-8            # Stefan-Boltzmann (W/m2 K4)
L_v = 2.26e6                      # Latent heat (J/kg)
alpha = 0.85                      # Basin absorptivity
tau = 0.9                         # Glass transmittance
h_cga_default = 5.0               # Convective glass-air (W/m2 K) 

dt_sec = 60  # timestep (s)

# Globals to hold time and irradiance arrays
t_seconds = None
t_hours = None
G_time = None
t_start_hr = None
t_end_hr = None



# 2) Load irradiance model

def load_polynomial_irradiance(json_file="irradiance_model.json",
                               start_hr=8.0,
                               end_hr=18.0):
    global t_seconds, t_hours, G_time, t_start_hr, t_end_hr

    with open(json_file, "r") as f:
        model_data = json.load(f)

    coeffs = np.array(model_data["coefficients"])
    poly = np.poly1d(coeffs)

    t_start_hr, t_end_hr = start_hr, end_hr
    t_hours = np.arange(t_start_hr, t_end_hr + dt_sec / 3600, dt_sec / 3600)
    t_seconds = t_hours * 3600.0
    G_time = np.clip(poly(t_hours), 0.0, None)

    print("Loaded polynomial irradiance model from:", json_file)
    if "equation" in model_data:
        print("Equation:", model_data["equation"])
    if "total_irradiance" in model_data:
        print("Total irradiance:", model_data["total_irradiance"], "W/m²·day")
    print(f"Simulation window: {t_start_hr:.1f}–{t_end_hr:.1f} h, Δt = {dt_sec:.0f}s")

    return lambda t: np.clip(poly(t), 0.0, None)



# 3) Physical helper functions

def p_sat_pascals(T_K):
    T_C = T_K - 273.15
    return 610.78 * np.exp(17.27 * T_C / (T_C + 237.3))


def signed_cuberoot(x):
    return np.sign(x) * (np.abs(x) ** (1 / 3))


def h_conv_internal(Tw_K, Tg_K):
    Tw = Tw_K - 273.15
    Tg = Tg_K - 273.15
    Pw = p_sat_pascals(Tw_K)
    Pg = p_sat_pascals(Tg_K)
    term = (Tw - Tg) + ((Pw - Pg) * (Tw + 273.15)) / (268900.0 - Pw + 1e-9)
    h_c = 0.884 * signed_cuberoot(term)
    h_c = max(h_c, 1e-6)
    return h_c, Pw, Pg


def h_evap(Tw_K, Tg_K, h_c, Pw, Pg):
    deltaT = (Tw_K - Tg_K)
    if abs(deltaT) < 1e-6:
        deltaT = 1e-6
    return 0.016273 * h_c * (Pw - Pg) / deltaT


def Q_rad_flux(Ta_K, Tb_K, emissivity=1.0):
    return emissivity * sigma * (Ta_K**4 - Tb_K**4)



# 4) ODE system for solar still 

def solar_still_rhs(t_sec, y, params):
    Tw_K, Tg_K, M_col = y
    A = params["A"]
    depth = params["depth"]
    h_cga = params["h_cga"]
    T_amb_K = params["T_amb_K"]
    T_sky_K = params["T_sky_K"]

    Tw_K = float(np.clip(Tw_K, 233.0, 373.0))
    Tg_K = float(np.clip(Tg_K, 233.0, 373.0))

    idx = int(round((t_sec - t_seconds[0]) / dt_sec))
    idx = np.clip(idx, 0, len(G_time) - 1)
    G_inst = G_time[idx]

    m_w = rho_water * depth * A
    m_g = rho_glass * glass_thickness * A
    Cw = m_w * c_w
    Cg = m_g * c_g

    Q_solar_absorbed = tau * alpha * G_inst * A
    h_c, Pw, Pg = h_conv_internal(Tw_K, Tg_K)
    h_ew = h_evap(Tw_K, Tg_K, h_c, Pw, Pg)

    Qconv_wg = h_c * (Tw_K - Tg_K)
    Qevap_flux = h_ew * (Tw_K - Tg_K)
    Qrad_wg = Q_rad_flux(Tw_K, Tg_K, emissivity=epsilon_g)
    Q_w_to_g = (Qconv_wg + Qevap_flux + Qrad_wg) * A

    Qconv_ga = h_cga * (Tg_K - T_amb_K) * A
    Qrad_gsky = Q_rad_flux(Tg_K, T_sky_K, emissivity=epsilon_g) * A

    dTw_dt = (Q_solar_absorbed - Q_w_to_g) / Cw
    dTg_dt = (Q_w_to_g - (Qconv_ga + Qrad_gsky)) / Cg

    m_evap_dot = (Qevap_flux * A) / L_v
    dMcol_dt = max(m_evap_dot, 0.0)

    return [dTw_dt, dTg_dt, dMcol_dt]



# 5) Simulation runner

def run_simulation(A=A_default, T_amb_C=30.0, T_sky_C=20.0):
    if G_time is None:
        raise RuntimeError("Irradiance not loaded — call load_polynomial_irradiance() first.")

    params = dict(
        A=A,
        depth=water_depth,
        h_cga=h_cga_default,
        T_amb_K=T_amb_C + 273.15,
        T_sky_K=T_sky_C + 273.15,
    )

    Tw0 = params["T_amb_K"]
    Tg0 = params["T_amb_K"]
    y0 = [Tw0, Tg0, 0.0]

    sol = solve_ivp(
        solar_still_rhs,
        (t_seconds[0], t_seconds[-1]),
        y0,
        args=(params,),
        method="RK45",
        t_eval=t_seconds,
        max_step=dt_sec,
        rtol=1e-6,
        atol=1e-8,
    )
    return sol



# 6) Post-processing and plotting

def compute_hourly_mass(sol, A=A_default):
    times_sol, Tw_sol, Tg_sol = sol.t, sol.y[0], sol.y[1]
    Qevap_flux = []

    for TwK, TgK in zip(Tw_sol, Tg_sol):
        h_c, Pw, Pg = h_conv_internal(TwK, TgK)
        h_ew = h_evap(TwK, TgK, h_c, Pw, Pg)
        Qevap_flux.append(h_ew * (TwK - TgK))
    Qevap_flux = np.array(Qevap_flux)
    m_dot_total = Qevap_flux * A / L_v

    n_hours = int((t_seconds[-1] - t_seconds[0]) / 3600)
    hour_edges = [t_seconds[0] + i * 3600 for i in range(n_hours + 1)]

    hourly_mass = []
    for i in range(n_hours):
        t0, t1 = hour_edges[i], hour_edges[i + 1]
        mask = (times_sol >= t0) & (times_sol <= t1)
        if not np.any(mask):
            hourly_mass.append(0.0)
        else:
            m_int = np.trapz(m_dot_total[mask], times_sol[mask])
            hourly_mass.append(m_int)
    return np.array(hourly_mass)


def plot_results(sol, A=A_default):
    times_sol = sol.t
    Tw_C = sol.y[0] - 273.15
    Tg_C = sol.y[1] - 273.15
    n_hours = int((t_seconds[-1] - t_seconds[0]) / 3600)
    hours_plot = np.arange(t_start_hr, t_start_hr + n_hours)

    Tw_hourly = []
    Tg_hourly = []
    for h in range(n_hours): 
        t_target = (t_start_hr + h + 1) * 3600 - 1
        idx = np.argmin(np.abs(times_sol - t_target)) 
        Tw_hourly.append(Tw_C[idx]) 
        Tg_hourly.append(Tg_C[idx])

    plt.figure(figsize=(10, 4))
    plt.plot(hours_plot, Tw_hourly, "-o", label="Water Temp (°C)")
    plt.plot(hours_plot, Tg_hourly, "-s", label="Glass Temp (°C)")
    plt.xlabel("Hour")
    plt.ylabel("Temperature (°C)")
    plt.title(f"Solar Still Temperatures (A={A:.2f} m²)")
    plt.grid(True)
    plt.legend()
    plt.show()

    hourly_mass = compute_hourly_mass(sol, A)
    plt.figure(figsize=(10, 3))
    plt.bar(hours_plot, hourly_mass, width=0.8)
    plt.xlabel("Hour")
    plt.ylabel("Collected mass (kg/hr)")
    plt.title("Hourly Water Collection")
    plt.grid(True)
    plt.show()

    total_mass = hourly_mass.sum()
    print(f"Total collected mass: {total_mass:.4f} kg for A={A:.2f} m²")
    return hourly_mass, total_mass


# 7) Area search utilities + Bisector Plot

def production_for_area(A, T_amb_C=30.0, T_sky_C=20.0):
    sol = run_simulation(A, T_amb_C, T_sky_C)
    hourly_mass = compute_hourly_mass(sol, A)
    return hourly_mass.sum()


def find_area_for_target(target_mass=20.0, A_min=0.1, A_max=30):
    """Find area by brentq and plot bisector search trend."""
    def fA(A):
        return production_for_area(A) - target_mass

    print(f"Searching for area producing {target_mass} kg/day")

    # --- record trial points for plotting ---
    trial_As = np.linspace(A_min, A_max, 10)
    trial_Ms = [production_for_area(A) for A in trial_As]

    try:
        A_root = brentq(fA, A_min, A_max, xtol=1e-3, rtol=1e-3)
    except Exception as e:
        print("Brent search failed:", e)
        A_root = np.nan

    # --- plot bisector-style diagram ---
    plt.figure(figsize=(7, 4))
    plt.plot(trial_As, trial_Ms, "o-", label="Simulated mass output")
    plt.axhline(target_mass, color="r", linestyle="--", label="Target mass")
    if np.isfinite(A_root):
        plt.axvline(A_root, color="g", linestyle=":", label=f"A_opt = {A_root:.2f} m²")
    plt.xlabel("Still Area (m²)")
    plt.ylabel("Daily water yield (kg)")
    plt.title("Bisector / Area Optimisation Plot")
    plt.grid(True)
    plt.legend()
    plt.show()

    if np.isfinite(A_root):
        mass = production_for_area(A_root)
        print(f"→ Found A = {A_root:.3f} m² producing {mass:.3f} kg")
        return A_root, mass
    return None, None



# 8) Example main run

if __name__ == "__main__":
    load_polynomial_irradiance("irradiance_model.json")

    sol = run_simulation(A=A_default)
    #hourly_mass, total_mass = plot_results(sol, A=A_default)
    

    A_needed, mass = find_area_for_target(60.0)
    
    sol_1 = run_simulation(A=A_needed)
    hourly_mass_1, total_mass_1 = plot_results(sol_1, A=A_needed)
    
    if A_needed:
        print(f"Required area ≈ {A_needed:.3f} m² → {mass:.3f} kg/day")
        
    
        
